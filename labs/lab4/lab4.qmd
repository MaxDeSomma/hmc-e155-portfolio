---
title: 'Lab 4: Digital Audio'
format:
  html: 
    code-links:
      - text: "Lab Repository"
        href: https://github.com/MaxDeSomma/e155-lab4
        icon: github
---

## Introduction
In this lab we were tasked with using our STM32 MCU to play music. 

## Lab Overview
The goal of the lab was to use the internal peripheral timers of the MCU to generate square waves and toggle a GPIO pin at a specicific frequency. The GPIO pin was then hooekd up to a audio circuit that magnified the signal and drove a small speaker. Additionally, the MCU was programmed to read a list of notes (Hz) and duration (ms) to play a score. 

## MCU Design
### Headers
The first piece designed in this lab were the headers for the specific modules used in the lab as we were not allowed to use any preexisting registers. The header files included were for the `RCC`, `GPIO`, `TIM6` and `TIM16` modules. 

![](images/headerFile.png)

An example header above shows how the Timer 16 module is broken up into different registers starting at the base address of `tim16` making it easy to change a bit in a specific register. These headers could then be used in main to shift bits and call other related functions. 

### Clock Control
Below is the clock tree of the entire MCU. The first step is sending the system clock signal to all peripherals as they are off after reset to save power.

![](images/clockTree.png)

 For this lab I used the default `MSI` 4 MHz clock as the system clock and enabled the `GPIO`, `TIM^`, and `TIM16`. Additionally before enter the the timer 6 and timer 16 a prescaler was used to divide the system clock to a 1 MHz signal. Enable and scaling down the clock involved setting the correct registers of the `RCC` module (reset & clock control) which can be seen at the top of main.

### Timer 6 (delay)
Timer 6 or `TIM6` which is a basic clock. Was used to create a accurate delay in milliseconds that would be used to hold notes for a certain amount of time. You can see how it recieves its internal clock from RCC. 

![TIM6 Block Diagram](images/timer6BlockDiagram.png)

A function called `setUpTIM6` was used where timer 6's inputed clock was scaled down by a factor of 10 leaving it at 100 kHz using the modules prescaler. It was then updated and its counter was enabled to start counting up at a rate of around 100 kHz. 

For the delay `delayTIM6(int ms)` was used. In this function the timer's auto reload bits were set. Auto reload is a feature that resets the timer's counter back to zero and raises a status register to know when that count is first hit. This allows us to contorl the delay as the auto reload register was set depednign on the input `ms` and then the program would then wait till the status register flag was raised before continuing on with any other code while reseting the status register back to zero for the next delay.

### Timer 16 (PWM)
Timer 16 or `TIM16` is a general purpose timer that has more features than timer 6 displayed below. It was used to create a PWM signal that was routed to a GPIO pin. Similarly it recieves its internal clock from RCC. 

![](images/timer16BlockDiagram.png)

The `setUpPWM(int frequency, int dutyCycle)` was used to enable the timer and have it output a signal at the correct frequency and duty cycle. For PWM the auto reload register and  capture/compare register must be set. This is because the output is low when `ARR` (auto reload register) < `CCR1` (capture/compare register) and high when `ARR > CCR1`. `ARR` was set based on the timers clock input as well as the functions `frequency` input and `CCR1` was set to a fraction of `ARR` depeding on what `dutyCycle` was inputed. 

From there the auto preload reload, capture/compare, PWM mode, main output, and preload register are enabled in addition to setting the capture/compare channel as an output as we want to output our PWM. Lastly everythign was updated and then the counter was enabled for timer 16 to begin counting up. 

To change the frequency or duty cycle `changeFreq(int frequency, int dutyCycle)` was used. This function then set `ARR` and `CCR1` according to the specified frequency and duty cycle and updated timer 16. 

### GPIO
In E85 and in previous examples we had used the GPIO as standard output or input. Either reading in low and high signals or outputting low and high signals. But now we want to connect it the output of our timer 16. To do this GPIO alternate function was used. Inside the STM 32 every pin has alternate functions which you can find in the data sheet like the example below. 

![](images/alternateFunctions.png)

As we can see the output from `TIM16_CH1` which is the PWM can be routed to pin `PA6` if its using alternate function 14. 
