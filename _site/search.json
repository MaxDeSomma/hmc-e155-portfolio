[
  {
    "objectID": "posts/third-post.html",
    "href": "posts/third-post.html",
    "title": "My Oscilloscope Odyssey",
    "section": "",
    "text": "This weeks lab was described as “a thinking persons lab” and it was nothing short of that. We had to design an FPGA to drive and read in inputs from a 16 button keypad, displaying the numbers on a dual seven segment display, easy right? This meant accounting for switch bouncing, shifting new hexadecimal numbers onto the dual display, and making sure that the external human input is synchronized with the system clock. Simulation turned out to be imperative for a design of this scale, however simulation can’t tell you everything. One constraint for this lab was that while one button is held the user should not be able to register another press of any button. However I kept running into a problem that was not caught in simulation. Anytime I pressed a button and then pressed a button in its respective column the seven segment would register the new keypress. Acknowledging this problem I frustratingly went through my code dozens of times and ran many more simulation to no success. While my past history using an oscilloscope had been dodgy I knew I woukld need to test the physical properties of the circuit. I realized that by pressing another column it was bouncing the SystemVerilog’s current state out into the scanning states, but I didn’t get why. I unenthusiastically hooked up the oscilloscope held one key and pressed the one right above, producing the following image.\n\n\n\nsrc: scaler.com\n\n\nTo my horror my held button signal would drop every time another key in the same column was pressed, driving it from 3.3 V to 0 V for split seconds. This was a huge moment in my lab as not only did I finally understand what bug was preventing me from finishing my design but I also understood why the oscilloscope is so useful. This phenomenon occured because when scanning the rows my modules forced the held button’s row high while the other row’s low meaning when another button in the same column was pushed down, the 3.3 V signal was fighting the 0 V signal coming into the same column pin forcing it to have the effect above. After visualizing that I was able to easily put in a work around to successfully debug my circuit! To simply conclude the oscilloscope is “a thinking persons tool.”"
  },
  {
    "objectID": "posts/seventh-post.html",
    "href": "posts/seventh-post.html",
    "title": "Surfing in San Diego",
    "section": "",
    "text": "This past week was fall break. Fall break is a short gap from school where we have Monday and Tuesday off from classes. This year for fall break I decided to visit my sister who lives in San Diego in order to try to learn how to surf. Like every other person who lives in San Diego my sister has begun to learn how to surf and would always brag about how good she was. Being a younger brother I naturally doubted her abilities and would tell myself I would be a better surfer than her with one day and had to prove it.\nMy roommate and I drove down to San Diego Friday night and was expecting a warm beach town like everyone thinks it is. \nHowever to our surprise it was overcast, cold, and foggy much like San Francisco. \nWe woke up early saturday morning at 7:30 am and walked a mile down the street barefeet each carying an 8 foot long foam surfboard. Arriving on the sand we couldn’t even see the water with the amount of fog that had rolled in but we plunged ourselves into the Pacific ocean. Hands and feet immediately went numb but the wetsuit we had rented kept the rest of our body surpsingly toasty. Under my sisters guidence my roomate and I timidly paddled out. Already paddling was more difficult that I imagined and I used to swim for CMS. To make it worse we were genuinely horrible at timing the waves, getting smacked by each and every one. Finally we made it out and turned around for our first wave. To no surprise we did not catch it. When we did finally catch a wave all we could manage was white water and getting to our knees. It was much much harder than we imagined. Turning to look at my sister I assumed she was surely having as bad of a time as we were. Unfortunately what I saw was truly impressive. She was flawlessy catching much bigger waves and actually standing on her surfboard which is much more challenging to use that the giant foam ones we had. We continued to surf for another two hours until the fog eliminated all eyesight. To my dismay I did have to admit to my sister that she was better than me but I hope to try again and maybe I will be better than her on my second day."
  },
  {
    "objectID": "posts/ninth-post.html",
    "href": "posts/ninth-post.html",
    "title": "Power of Pause",
    "section": "",
    "text": "This week in my prototyping my future self class we learning about the “power of pause”. This involves taking a break from work and pausing the stressors in your life. At Mudd this is hard to wrap your head around. It always feels like you need to be working on something or you are falling behind. I have often had to choose between school or spending time with freinds and on hobbies I’m passionate about. Additionally there it felt as if there was little time to rest if I got sick or wasn’t feeling 100%. However I am beginning to learn that sometimes taking a break can actually be more beneficial than the cost of time you lose by that taking that break. These breaks don’t need to be long but can simply be calling a loved one or taking a short hike outside. If you try to keep banging your head against a problem set or lab it will often take longer to find the answer. In hindsight this is clear but I always thought that taking a break seemed like a waste of time. Going forward I think I will try to determine when I could use a break and actually take a pause seperating myself completely from the problem and not thinking about it for a while."
  },
  {
    "objectID": "posts/fourth-post copy.html",
    "href": "posts/fourth-post copy.html",
    "title": "System on a Chip",
    "section": "",
    "text": "System-on-a-chip (SoC) is an integrated circuit that combines all the essential components of a computer on a singlular chip. SoCs have been popular in the mobile industry as you could combine the CPU, GPU, memory and other components on one chip leading to better power efficiency and space savings. This resulted in the boom of lighter, smaller, and longer lasting phones. Recently system on a chip design have begun to invade the computer market for the same benefits.\n\nApple had made a huge surge in SoC computers with their M1, M2, M3, and now M4 procesors. These chips were extremely succesful rocking the laptop market with extremely thin, light, and powerful laptops that boast better battery life as well. Window based computers have recently tried to jump on this train with ARM based SoC designs. While the computers have had impressive performance reviews a lot of windows apps have not been ported from the x86 architecture that AMD and Intel use to the newer ARM architecture. The lack of porting has led to new Windows devices not being fully capable of efficiently running some apps, leading to increased performance in some and slower speeds in other. I believe that this it is just a factor of time before SoC becomes dominant for mobile computer devices and I am interested to see what happens next."
  },
  {
    "objectID": "posts/fifth-post.html",
    "href": "posts/fifth-post.html",
    "title": "Printed Circuit Boards",
    "section": "",
    "text": "This week Professor Brake was out of town so the class taught themselves how to design PCB’s using KiCad. I had onyl ever used PCB’s but had never realized how they were designed or manufactured. This made me interested in learning about some of the history of PCB’s and where they came from.\nIn the early 1900’s PCB had not yet been invested and were built by manually winding copper around metal conductors. This meant building a circuit was a labor intesive, error full, and unreliable ordeal. In 1925 Charles Ducas created a patent of the earliest precursor to a PCB. He had created a way of making electrical paths on an insulated surface using conductice ink, literally “printed.”\n s Then in 36’ Paul Eisler had a huge breakthroughs in the UK. He had developed a way to print electrical circutis on a non doncutive base using copper foil. This gained huge popularity giving him the honor of being credited with inventing the modern PCB. Additionally the idea was accelerated during World War II finding great use in radios and military equipment. After WWII people realized how efficient PCB’s were and began using them in consumer products. Products continued to imrpove in the 60’s as SMT or surface mount technology were invented.\n\n\n\nYou can see SMT on C9 vs the THT on C5\n\n\nThis allowed chip components to be mounted on the surface instead of in through holes saving a lot of space allowing for a more complicated chip in a small area. From the 80’s onwards PCB’s were used in almost all electronic devices. However PCB development has not stagnated now a days Computer-Aided Design has allowed anyone to be able to design and create their own custom PCB like we did in class. More surprising is how fast and cheap it is for anyone to be able to pickup this skill and get their own PCB in their hands in a few days. I hope to get to use mine in Lab 6."
  },
  {
    "objectID": "labs/lab7/lab7.html",
    "href": "labs/lab7/lab7.html",
    "title": "Lab 7: The Advanced Encryption Standard",
    "section": "",
    "text": "In this lab we were tasked with creating a hardware accelerator to perform 128-bit AES encryption."
  },
  {
    "objectID": "labs/lab7/lab7.html#introduction",
    "href": "labs/lab7/lab7.html#introduction",
    "title": "Lab 7: The Advanced Encryption Standard",
    "section": "",
    "text": "In this lab we were tasked with creating a hardware accelerator to perform 128-bit AES encryption."
  },
  {
    "objectID": "labs/lab7/lab7.html#lab-overview",
    "href": "labs/lab7/lab7.html#lab-overview",
    "title": "Lab 7: The Advanced Encryption Standard",
    "section": "Lab Overview",
    "text": "Lab Overview\nThe goal of this lab was to use our FPGA as a hardware accelerator to perform 128 bit AES encryption must faster than the MCU could. We used the MCU to send plaintext and a key to the FPGA over SPI which then encrypted the message and sent it back to MCU."
  },
  {
    "objectID": "labs/lab7/lab7.html#aes",
    "href": "labs/lab7/lab7.html#aes",
    "title": "Lab 7: The Advanced Encryption Standard",
    "section": "AES",
    "text": "AES\nAES or the Advanced Encryption Standar is a symmetric encryption algorithm that is used world wide to secure data. It became popular in 2001 as a relatively simple but efficient way to encrypt peoples data based on a certain key. This allowed messages to securely travel to people who had the same key and could unlock the message while looking like gibberish to whoever else intercepted it. AES encryptes data by applying a series of tranformations to plaintext and mixing it with key for multiple rounds. These transformations and mixing make it a perfect process for the FPGA which can perform these operations extremely quickly. The transformatons include subBytes, shiftRows, mixcolumns and the key mixing is in the function addRoundKey. The whole pattern is shown in the diagram below.\n\n\n\nbraincoke.fr"
  },
  {
    "objectID": "labs/lab7/lab7.html#designing-the-aes-controller-and-submodules",
    "href": "labs/lab7/lab7.html#designing-the-aes-controller-and-submodules",
    "title": "Lab 7: The Advanced Encryption Standard",
    "section": "Designing the AES Controller and Submodules",
    "text": "Designing the AES Controller and Submodules\nThe first step was to design each transformation and key mixing submodule. Luckily mixcolumns was alrady provided for us, however subBytes was tricky as it involves substituting bytes in the 128 bit partially encoded sequence with bytes defined in a look up table shown below.\n\nThis lookup table was giant so it couldn’t be stored in the FPGA. However it was able to be stored in DRAM and accessed in the subModule. From there the subButes submodule parsed the 128 bit input and replaced each byte with the corresponing look up table value.\nNext up was shiftRows which simply left shifted each row by 0, 1, 2, or 3 bytes respectively. This submodule is described below.\n\nLastly was addRoundKey which ended up being both the simplest and most confusing. addRoundKey is simple as all you do is XOR each column with the roundKey. However computing the roundKey is not simple. Since our addRoundKey ended up being used 11 times we had to generate 11 roundKeys Each round key is broken down into 4 words (total of 44 words) and is described by the psuedocode below\n\nAnd can be more clearly visualized in the example:\n\nWe can see that the first 4 words are the original key of the AES encryption. For each additional set of four words (index 4 through 43) the previous word is set as a starting point, then shifted left by one byte, substituted based on the look up table described in subBytes, XOR’ed by rcon which changes each round, and finally XOR’ed with the word that has an index of 4 less than the current word. The next three words are then the previous word XOR’ed with the word four before.\nAfter all the submodules were designed it was time to piece them together in the AES controller. The block diagram of the entire aes module is given below.\n\nI followed this schematic when writing the system verilog code. Connecting modules and using different enabled flipflops to know when to move data in different rounds and for specific timing."
  },
  {
    "objectID": "labs/lab7/lab7.html#testing",
    "href": "labs/lab7/lab7.html#testing",
    "title": "Lab 7: The Advanced Encryption Standard",
    "section": "Testing",
    "text": "Testing\nWhen testing I first simulated using waveforms in model sim. I first individually tested each submodule. An example of testing mixRows is below.\n\nAs you can see these consited of simple tests with just an input to the function. I then looked at the output on the waveform for the desired output. I chose my input based on the Cipher example in Appendix B of National Institute of Standards and Technology AES publication.\nOnce I knew that all my submodules worked I was able to use Professor Brake’s large testbenches to test my entire system. In the photo below we start with an input plaintext and key and at the end we successfully determine the right cyphercode and raise the done flag to enable the SPI return!\n\nAfter confirming my simulations were working it was time to upload my code to my FPGA and wire up my board. Once it was wired up I used the physical logic analyzer to monitor the SPI process and determine if it worked as well as it did in simulation. Below is a photo from the logic analyzer showing the entire process.\n\nD2 is the chip enable and you can clearly see there is 32 packets of 8 bit data being sent to the FPGA which contains plaintext and key, 128 bits each, and then a short while later there are 16 more packets sent back to the MCU which contains the encrypted cyphercode.\n\nIn the Image above you can see a zoomed in version of each chip enable and can clearly see the plain text data beeing sent over one byte at a time!"
  },
  {
    "objectID": "labs/lab7/lab7.html#pinout",
    "href": "labs/lab7/lab7.html#pinout",
    "title": "Lab 7: The Advanced Encryption Standard",
    "section": "Pinout",
    "text": "Pinout\nTo wire up my MCU and FPGA, the following pin layout was used. \nPA10 and PA9 were used to verify if the returned cypher text was what we expected when we sent in the specific plaintext and key. PA9 would light up when correct and PA10 would light up when the encryption process failed or was done incorrectly."
  },
  {
    "objectID": "labs/lab7/lab7.html#outcomes",
    "href": "labs/lab7/lab7.html#outcomes",
    "title": "Lab 7: The Advanced Encryption Standard",
    "section": "Outcomes",
    "text": "Outcomes\nWhile this lab was one of the most brain wracking the outcomes was probably the most lacklaster of all labs. Fortunately I was able to fit the hardware from my systemVerilog code on my FPGA and get PA9 to light up verifying I ran the encryption algorithm properly using the FPGA as a hardware accelerator.\nTime Spent in Lab: 24 Hours"
  },
  {
    "objectID": "labs/lab5/lab5.html",
    "href": "labs/lab5/lab5.html",
    "title": "Lab 5: Interrupts",
    "section": "",
    "text": "In this lab we were tasked with using our stm32 MCU to determine the speed of a motor by reading from a quadrature encoder."
  },
  {
    "objectID": "labs/lab5/lab5.html#introduction",
    "href": "labs/lab5/lab5.html#introduction",
    "title": "Lab 5: Interrupts",
    "section": "",
    "text": "In this lab we were tasked with using our stm32 MCU to determine the speed of a motor by reading from a quadrature encoder."
  },
  {
    "objectID": "labs/lab5/lab5.html#lab-overview",
    "href": "labs/lab5/lab5.html#lab-overview",
    "title": "Lab 5: Interrupts",
    "section": "Lab Overview",
    "text": "Lab Overview\nThe goal of this lab was to use interrupts to to interface with the quadrature encoder and calculate the speed of a motor. The interrupts needed to be triggered on the edges of the encoder pulses so that we could accurately find the duration between pulses. Lastly our design needed to display the speed and direction of the motor to the user at a rate of at least 1 Hz."
  },
  {
    "objectID": "labs/lab5/lab5.html#what-is-a-quadrature-encoder",
    "href": "labs/lab5/lab5.html#what-is-a-quadrature-encoder",
    "title": "Lab 5: Interrupts",
    "section": "What is a quadrature encoder",
    "text": "What is a quadrature encoder\nAn encoder is a device that converts a set of inputs into a binary code output. A quadrature encoder is an encoder that is used to measure the angle of a motor. It can be designed a few ways. The ones in lab used hall effect sensors seen in the image below.\n\n\n\nUC Berkeley IEEE\n\n\nAs the motor spins the hall effect sensors will output a square wave. The two sensors are seperated by 90 degrees meaning the two respective square waves are 90 degrees out of phase. We can then use this to find the period between the rising or falling edges and use that to calculate the speed of the motor."
  },
  {
    "objectID": "labs/lab5/lab5.html#mcu-design",
    "href": "labs/lab5/lab5.html#mcu-design",
    "title": "Lab 5: Interrupts",
    "section": "MCU Design",
    "text": "MCU Design\n\nSetup\nIn this lab we were allowed to use the CMSIS library meaning we no longer had to design structs for each register used in this lab. However we still need to need to make our own register specific functions which we can pull from our growing library we started last lab.\nIn this lab we needed to continually check if the two signals from the encoder were rising or falling. One way to do that would be to use polling. This would mean in our main loop we could have manually checked if the GPIO pin connected to the encoder output changed. However there is a large issue with polling which is that the all the logic in the while loop takes time to evaluate, meaning that when you check for GPIO you could miss the signal if the other part of your main loop are running. We need a way to immediately raise a flag if our the input changes. Luckily this is where interrupts come in. Interrupts are a way to tell the MCU to give immediate attention if a signal is changed. We can input our encoder signal and then whenever the signal has a risign or fallign edge the MCU will immediately run a service routine that executes some small but crucial code.\nThe first part of the MCU design was to enable the GPIO pins that will read in the quadrature encoder. In this lab PA6 and PA8 were used. I originally was going to use PA5 and PA6 however the encoder outputs 5 V signals and PA5 is only rated for 3.3 V. These pins were then enabled and set as input. Afterwards two timers were initiated. TIM2 was used as a delay timer that counted at a frequency of 1 kHz (period of 1ms) and TIM6 was used as timer to measure the time between the encoder signals. Given that it was measuring relatively quick signals I wanted to the frequency to be much faster so it was prescaled to 1 MHz (period of 1 us).\nThe interrupts were then enabled using RCC and setting the configuration and mask register so that PA6 and PA8 would trigger an interrupt. The interrupts were then set to trigger on both the falling and rising edge of the signal. Lastly the Nested Vectored Interrupt Controller was configured to allow the CPU to respond to interrupt lines 9 through 5 thus including 6 and 8 which correspond to our pins.\nThe specific service routine under the function prototype void EXTI9_5_IRQHandler(void); could then be configured to whatever logic we wanted to apply in the interrupt.\n\n\nInterrupt Design\nOnce an the interrupt is triggered and service routine funciton is called the first thing to do is check which pending register was enabled as this tells the code if the signal came from PA6 or PA8. If both PA6 and PA8 are at the different values TIM6 is reset back to a count of zero and then when PA6 and PA8 are at the same value either high or low the current count of TIM6 is saved to a global variable called delta. The flow chart is included below.\n\n\n\nLoop Design\nThe most important function in the main loop is calculating the speed of the motor. The speed is calculated in terms of revolutions per second based on the time between edges we recieve in the interrupts. The main loop is also in charge of printing the speed using printf() and causing a delay of around 250 ms so that we don’t printf too rapidly. Lastly we check the time between edges and if there is too much seperation we assume the motor is off and set the speed to zero."
  },
  {
    "objectID": "labs/lab5/lab5.html#calculations",
    "href": "labs/lab5/lab5.html#calculations",
    "title": "Lab 5: Interrupts",
    "section": "Calculations",
    "text": "Calculations\nThe main calculation in this lab was using delta which is the timer count corresponding to a quarter wave period to a motor speed. We know we want revolutions per second \\(\\frac{r}{s}\\). From the data sheet we know there is 120 pulses per rotation \\(120 \\frac{p}{r}\\). Therefore we can use \\(\\frac{r}{p}*\\frac{p}{s} = \\frac{r}{s}\\). To find \\(\\frac{p}{s}\\) the first thing we can do is take the quarter wave count and multiply it by \\(4\\) to get the full wave count. We then divide it by \\(1,000,000\\), which is our clock frequency, to get the period of a full pulse wave in seconds \\(\\frac{s}{p} = \\frac{4\\Delta}{1000000}\\). We then know \\(\\frac{r}{s} = \\frac{1000000}{4\\Delta} * \\frac{1}{120} =  \\frac{1000000}{480\\Delta}\\). We can use this equation in our main while loop to calulate the revolutions per second."
  },
  {
    "objectID": "labs/lab5/lab5.html#performance",
    "href": "labs/lab5/lab5.html#performance",
    "title": "Lab 5: Interrupts",
    "section": "Performance",
    "text": "Performance\nTo verify the design for this lab we can compare our calculated revolutions per second to the oscilloscope readings. One thing I noticed when measuring with the oscilloscope was that the frequency varied a lot. Below are some images of the oscilloscope measuring the same 5 V driven motor.\n\n\n\n505 Hz\n\n\n\n\n\n472 Hz\n\n\n\n\n\n444 Hz\n\n\nFrom these images you can see that the frequency jumps around a little bit meaning the motor does not stay at one constant speed.\nI ended up measuring the time between pulses on the scope below and found a quarter period of 460 us.\n\nUsing 460 us we found that the motor is spinning at a rate of 4.529 rev/s. When our MCU code ran the program on the same 5 V motor our speed fluxuated similar to the oscilloscope frequency readings but stayed around 4.46 rev/s. I has happy with the small error and believe some of the error could be due to the fact that the motor is not always spinning at the same frequency."
  },
  {
    "objectID": "labs/lab5/lab5.html#outcome",
    "href": "labs/lab5/lab5.html#outcome",
    "title": "Lab 5: Interrupts",
    "section": "Outcome",
    "text": "Outcome\nFrom the video below you can see the quadrature encoder motor spinning and the printing speeds on the screen. Not displayed in the video is the power supply controlling the motors speed. In the video I vary the voltage applied to the motor and we can see that the the printed speed varies accordingly. Additionally one feature that took a while to implement was displaying when the motor was off and had a speed of zero revolutions per second, but in the video we can see when the motor turns off the display quickly notifies you that the motor has a speed of zero.\n\nThis lab, while in hindsight was not as complex as it seemed in the moment, was a great introduction to using interrupts and made me more comfortable knowing when and how to use them. In the future I would want to work on using more velocity smoothing as this motor seems to fluxuate its speed by small amounts which is apparent in the video.\nTime in Lab: 15 Hours."
  },
  {
    "objectID": "labs/lab3/lab3.html",
    "href": "labs/lab3/lab3.html",
    "title": "Lab 3: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "In this lab we learn how to use the FPGA to scan inputs from a 4x4 keypad."
  },
  {
    "objectID": "labs/lab3/lab3.html#introduction",
    "href": "labs/lab3/lab3.html#introduction",
    "title": "Lab 3: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "In this lab we learn how to use the FPGA to scan inputs from a 4x4 keypad."
  },
  {
    "objectID": "labs/lab3/lab3.html#lab-overview",
    "href": "labs/lab3/lab3.html#lab-overview",
    "title": "Lab 3: FPGA and MCU Setup and Testing",
    "section": "Lab Overview",
    "text": "Lab Overview\nThe goal of this lab was to use 16 button keypad to display the last two hexadecimal digitals pressed on the double seven segment display. This becomes more tricky than it sounds. This is because the FPGA must fight against switch bouncing and metastability. The keypad is just a series of rows and columns that are connected depending on which button is pressed. When pushed a connection is formed and there is a short between the specific row and column.\n\nSwitch bouncing displayed in the diagram below, is the phenomenon where signals from a switch can appear as if they are flipped on and off repeatedly in an extremely short time frame. This is due to the physical characteristic of buttons. When the two peices of metal come together to form a connection they make contact initially for a small amount of time and then seperate until connecting again, repeating this cycle until it is fully connected.\n\n\n\ncircuitdigest.com\n\n\nDepending on your button you might see zero switch bouncing or extreme switch bouncing ranging from a few micro seconds to milliseconds. After testing the lab keypad I found that they had zero switch bouncing on any button as you can see from the oscilloscope below. However the systemVerilog still acounted for the possibility.\n\n\n\nOscilloscope of pressing a switch\n\n\nThe other problem the keypad has is metastability. Metastability can happen with digital logic when physical inputs don’t line up with the clock cycles correctly and are incorrectly sampled before the signal is fully stable. To fix that synchronizers were used to make sure the signal was stable. This can be accomlished using multiple flip flops and only using the stable output.\n\n\n\nnandland.com"
  },
  {
    "objectID": "labs/lab3/lab3.html#design-the-fsm",
    "href": "labs/lab3/lab3.html#design-the-fsm",
    "title": "Lab 3: FPGA and MCU Setup and Testing",
    "section": "Design the FSM",
    "text": "Design the FSM\nTo design this lab we had to implement an FSM to make sure that when a button held it is only registered as one valid press and you can’t press other buttons while its held. The following FSM was used.\n\nFor this lab I decided that the FGPA would output a signal to drive the rows high and the columns would be inputs to the FPGA to show when there is a vaild connection. However you can’t scan all four rows at the same time as then whenever a column recieved an input you wouldn’t be able to tell which button in the column it came from. To fix this the FSM scanned all the rows. Driving each one high seperately for one clock cycle each until the FPGA recieved a valid column signal. The FSM would then branch out holding that one row high to help determine which button is being pressed, and then it would enable the seven segment decoder to show a new number. Once the button is released it goes back to scanning.\nThe systemVerilog code followed the following block diagram.\n\nIn the top level module we defined the HSOSC and inputed that into the Master module. The master module then slowed down the clk and inverted the reset as the onboard switches use pull up resistors. The inputs c and reset then went into the synchronizer where we used two flip flops to make sure that c was stable as it entered the FSM. In the FSM en, counter, and rowPressed was generated which were used in the buttonDecoder and ledController. The FSM also determined which rows were powered by determining the logic for r. buttonDecoder took in c and rowPressed and then determined which four bit hexadecimal number it corresponded to outputting it as s. s,en, counter, clk, and reset was inputed into ledController which was built upon the last lab and was able to use time multiplexing to drive two seven segments displays outputting which seven segment should be based on led1 and led2 as well as the number seg. Additionally it used counter to create a digital low pass filter and make sure that if there was any switch bouncing it would not incorrectly affect the output."
  },
  {
    "objectID": "labs/lab3/lab3.html#testing-all-the-modules",
    "href": "labs/lab3/lab3.html#testing-all-the-modules",
    "title": "Lab 3: FPGA and MCU Setup and Testing",
    "section": "Testing all the Modules",
    "text": "Testing all the Modules\nDue this labs complexity a lot more was tested in simulation before it was uploaded to the FPGA and wired up. The modules simulated were buttonFSM, ledController, and buttonDecoder. We first tested the buttonDecoder module. This involved making a simple testbench that gave it some example key presses to determine if it would output the correct 4-bit signal representing the hexadecimal pressed. From the wave below you can see that it outputs the correct signal based on the key pressed. You can also see that when two keys pressed together are simulated the ledDecoder goes to its default case statement of F however concerning the FSM should prevent two keys from being pressed simultaneously.\n\n\n\nledDecoder Test Bench\n\n\nThe next module tested was ledController. The idea behind ledController is similar to last lab where it drives a double seven segment display. However we also wanted it to shift the numbers over as a new one was pressed, shifting everything left and adding the new onw on the right if it had the proper enable from the FSM. From the wave output below it shows that s1 and s2 the two hexidecimal numbers for the two led displays only change when en is high and shift properly, with s1 getting s and s2 getting s1 in a flip flop. Additionally ledController switched which seven segment was on at the right speed and outputted the corresponding seven bit seg number to turn on certain diodes.\n\n\n\nledController Test Bench\n\n\nThe final module tested was the FSM. For the testbench of the FSM, it was simply initialized as the device under test and then reset. On the wave we can see that after it is reset it properly scans through all the rows powering them high. Then we can input a single column pretending as if there is a real time input. This results in a specific row staying high until the FSM move into the next state where all the rows are high so we don’t see any of the errors mentioned in my blog, until the button is released. However we have the rowPressed variable at the bottom that keep track of which row was pressed initially so that the ledDecoder works properly. It then returns to scanning again. Near the end of the wave an input of 1000 half a clock cycle later the input changes to 1100 simulating someone pressing another button. The module however does not change the colPressed and will output the correct hexadecimal number\n\n\n\nFSM Test Bench"
  },
  {
    "objectID": "labs/lab3/lab3.html#wiring-up-the-board",
    "href": "labs/lab3/lab3.html#wiring-up-the-board",
    "title": "Lab 3: FPGA and MCU Setup and Testing",
    "section": "Wiring up the board",
    "text": "Wiring up the board\nAfter making sure the simulated modules worked correctly they were uploaded to radiant and the board was wired to the following specification below.\n\nThe FGPA pins were then connected to the correct outputs and inputs in radiant, the video below shows a working lab3 where the the button pressed on the keypad show up on the dual seven segment display. 100kOhm resistors were used on the columns of the keypad to act as pulldown resistors showing a valid low signal when nothing was pressed. The resistors for the diode and dual seven segment display were kept the same from last lab."
  },
  {
    "objectID": "labs/lab3/lab3.html#outcome",
    "href": "labs/lab3/lab3.html#outcome",
    "title": "Lab 3: FPGA and MCU Setup and Testing",
    "section": "Outcome",
    "text": "Outcome\nThis lab turned out to be a success. However this lab writeup makes it seem easier than it was. There were dozens of small bugs and features that did not work initially and had to be reformed and changed. It was quite frustrating however I learn how to use the oscilloscope and simulation to my benefit. In the end the keypad was able to communicate user input to the FPGA shifting the dual seven segment display to the correct number on the right side. Additionally the synchronizers were used to get rid of metastable inputs, the FSM countered any switch bouncing from the keypad, and it properly dealt with multiple key presses at once.\nVideo\nTime in lab: 23 Hours."
  },
  {
    "objectID": "labs/lab1/lab1.html",
    "href": "labs/lab1/lab1.html",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "In this lab we soldered our E155 protoboard, tested our FPGA and MCU, and created our own FPGA design to drive onboard LEDs as well as a seven segment display."
  },
  {
    "objectID": "labs/lab1/lab1.html#introduction",
    "href": "labs/lab1/lab1.html#introduction",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "In this lab we soldered our E155 protoboard, tested our FPGA and MCU, and created our own FPGA design to drive onboard LEDs as well as a seven segment display."
  },
  {
    "objectID": "labs/lab1/lab1.html#development-board",
    "href": "labs/lab1/lab1.html#development-board",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Development Board",
    "text": "Development Board\nFor the development board we were given we soldered a variety of surface mount technology (SMT) and through hole technology (THT) components. The brains behind the development board consisto of the UPduino v3.1 FPGA and Nucleo-L432KC MCU which were attached through header pins. Additionally switches, voltage regulators, and jumpers to set power for the MCU and FPGA were added to the board. The most difficult part was soldering all the SMT leds, capacitors, and resistors as it was tricky to get them in the correct place with how small they were.\n\n\n\nCompleted Development Board"
  },
  {
    "objectID": "labs/lab1/lab1.html#testing-the-fpga-and-mcu",
    "href": "labs/lab1/lab1.html#testing-the-fpga-and-mcu",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Testing the FPGA and MCU",
    "text": "Testing the FPGA and MCU\nThe FPGA and MCU were then tested to make sure they worked properly along with all the soldered components on the PCB. They were able to be test by using the onboard PCB LEDs which connect internally to specific pins of the FPGA and MCU. For my board I found that three of my LEDS and one of the current limiting resistors needed to be reflowed. However after reflowing, and using Radiant to program the FPGA and Segger to program the MCU it worked worked succesfully.\n\n\n\nOn board LEDs used to test the FPGA and MCU"
  },
  {
    "objectID": "labs/lab1/lab1.html#fpga-design",
    "href": "labs/lab1/lab1.html#fpga-design",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "FPGA Design",
    "text": "FPGA Design\n\nLab Description\nAfter I had thoroughly tested that my FPGA, MCU, and development board, I designed FPGA modules to control different LEDs. The task was to light up the LED’s and a seven segment display depending on what dip switches were selected, described more in the table below.\n\n\n\nSignal Name\nSignal Type\nDescription\n\n\n\n\ns[3:0]\ninput\nthe four DIP switches (on the board, SW6)\n\n\nled[2:0]\noutput\n3 LEDs (you may use the on-board LEDs)\n\n\nseg[6:0]\noutput\nthe segments of a common-anode 7-segment display\n\n\n\nTwo of the LEDs, led[0] and led[1], were designed accordingly:\n\n\n\n\ns1\ns0\nled[0]\n\n\n\n\n0\n0\n0\n\n\n0\n1\n1\n\n\n1\n0\n1\n\n\n1\n1\n0\n\n\n\n\n\n\n\n\ns3\ns2\nled[1]\n\n\n\n\n0\n0\n0\n\n\n0\n1\n0\n\n\n1\n0\n0\n\n\n1\n1\n1\n\n\n\n\nled[2] did not follow a truth table but instead was designed to blink at 2.4 Hz.\nAs for the seven segment display it needs to read in the dip switch signals and display the four bit binary number as a single hexadecimal number on the seven segment display. For example if the dip switch input s[3:0] was 0110 the seven segment display must show a 6 while if it was 1101 it would display a d.\n\n\nDesign\nBelow is the block diagram used to design the combinational logic that that drove both the LEDs and seven segment display:\n\n\nLED Design\nTo design led[0] and led[1] we can clearly see that led[0] is simply an exclusive or (XOR gate) of input s0 and s1. While led[1] is an and gate of s2 and s3. For led[2] it was necessary to make sure it blinked at 2.4 Hz. This means that every cycle of led[2] will last around 0.4167 seconds. Using a duty cycle of 50%, the LED needs to switch on or off every 0.2083 seconds. The HSOSC library was utilized to create a clock that oscillated at 48 Mhz meaning it ticks every \\(2.083*10^-8\\) seconds. This meant that it would take \\(10^8\\) ticks to complete a half cycle for led[3]. To design this a flip flop was used that counts every tick and switched the led on or off every 10,000,000 counts.\n\n\nSeven Segment Design\nTo design the seven segment display the SystemVerilog module used a submodule which had an input of s[3:0] and an output of seg[6:0]. This submodule comntained a case statement with 16 cases, one for each off the possible dip switch combinations (4’b000, 4’b0001, … , 4’b1111). Once the SystemVerilog checked the case it would then turn off the specific pins that correlated to the specific segments to create each hexadecimal number. One interesting point about the seven segment display is that it was common annode, meaning it had one common pin at 3.3V, meaning the FPGA must drive the desired pin to low to light up the particular segment.\n\n\n\nTesting\nA test bench was used to test the SystemVerilog code was working according to the proposed design. The testbench ran all 16 cominations of the dip switches and tested the expected led[3:0] and expected seg[6:0] outputs vs what the actual output of the modules would be in simulation.\n// sevenSeg_testvectors.tv\n// Max De Somma\n// mdesomma@g.hmc.edu\n// 9/3/24\n\n// [3:0]s, [2:0]led, [6:0]segment\n0000_000_1000000\n0001_001_1110011\n0010_001_0100100\n0011_000_0100001\n0100_000_0010011\n0101_001_0001001\n0110_001_0001000\n0111_000_1100011\n1000_000_0000000\n1001_001_0000001\n1010_001_0000010\n1011_000_0011000\n1100_010_1001100\n1101_011_0110000\n1110_011_0001100\n1111_010_0001110\nThe test vector file above was the one used in the testbench that had the correct output for every case. Every test passed proving the SystemVerilog code worked correctly.\n\nHowever the testbench fell short as led[2] was not able to be tested which is clear in the photo above. This was due to the fact that the HSOSC libary was not include in model sim. However it was possible to validate it using an oscilloscope proving it oscillated between 0 V and 3.3V at a freq of 2.42 Hz which is close to the desired 2.40 Hz. \n\n\nWiring and Outcome\nAfter writing and testing the SystemVerilog, it was time to connect the LED’s and Seven Segment to my FPGA using the following wiring schematic.\n\nHowever to prevent the seven segment drawing too much current, current limiting resistors were added to all seven seg[7:0] pins targeting 15 mA. On the seven segment data sheet, it stated that the red led segments had a forward voltage of 1.8 V. This meant that voltage across the resistor would be 1.5 V, and thus could use V = IR with a target current of 0.15 mA to calculate R.\n\nAfter finally wiring all the inputs and the output to the FPGA and downloading the SystemVerilog module to the board the development board was succesfully able to drive the seven segment display and display the correct hexadecimal number and proper onboard LEDs. Additionally as shown above the led[2] blinked at the correct 2.4 Hz. This wraped up Lab 1, verifying that the development board worked properly while giving me a chance to design my own FPGA modules. In total this lab took 21 hours.\n\n\n\nThe correct output of led[0] and the Seven Segment displaying 6 for input 4’b0110\n\n\n\n\n\nThe correct output of led[1] and the Seven Segment displaying C for input 4’b110"
  },
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "E155 Blog",
    "section": "",
    "text": "lab 7 improvements\n\n\n\n\n\n\n\n\n\n\n\nNov 9, 2024\n\n\nMax De Somma\n\n\n\n\n\n\n\n\n\n\n\n\nPower of Pause\n\n\n\n\n\nWhy taking small breaks are beneficial\n\n\n\n\n\nNov 2, 2024\n\n\nMax De Somma\n\n\n\n\n\n\n\n\n\n\n\n\nSPI Invention\n\n\n\n\n\nThank you Motorola?\n\n\n\n\n\nOct 25, 2024\n\n\nMax De Somma\n\n\n\n\n\n\n\n\n\n\n\n\nSurfing in San Diego\n\n\n\n\n\nIts really cold\n\n\n\n\n\nOct 18, 2024\n\n\nMax De Somma\n\n\n\n\n\n\n\n\n\n\n\n\nIdeating a final project\n\n\n\n\n\nWhat could it be?\n\n\n\n\n\nOct 11, 2024\n\n\nMax De Somma\n\n\n\n\n\n\n\n\n\n\n\n\nPrinted Circuit Boards\n\n\n\n\n\nA brief history\n\n\n\n\n\nOct 4, 2024\n\n\nMax De Somma\n\n\n\n\n\n\n\n\n\n\n\n\nSystem on a Chip\n\n\n\n\n\nWhat is it?\n\n\n\n\n\nSep 27, 2024\n\n\nMax De Somma\n\n\n\n\n\n\n\n\n\n\n\n\nMy Oscilloscope Odyssey\n\n\n\n\n\nTurns out they might be useful\n\n\n\n\n\nSep 19, 2024\n\n\nMax De Somma\n\n\n\n\n\n\n\n\n\n\n\n\nWhat is Time Division Multiplexing\n\n\n\n\n\nNow I see it everywhere\n\n\n\n\n\nSep 11, 2024\n\n\nMax De Somma\n\n\n\n\n\n\n\n\n\n\n\n\nJumping into Micro Ps\n\n\n\n\n\nThe first week\n\n\n\n\n\nSep 4, 2024\n\n\nMax De Somma\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "Hello I am Max De Somma, a senior Engineering major at Harvey Mudd College in Claremont, California. My academic interests include a mixture of electrical and mechanical design which I am hoping to deepen in E155. I currently work in the student machine shop on campus where I help students and faculty learn how to safely operate heavy machinery. When I am not doing homework or in the shop, I enjoy riding bikes, swimming, and playing board games."
  },
  {
    "objectID": "labs/lab2/lab2.html",
    "href": "labs/lab2/lab2.html",
    "title": "Lab 2: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "In this lab we learned how to use time multiplxing to efficiently use the I/O on our FPGA."
  },
  {
    "objectID": "labs/lab2/lab2.html#introduction",
    "href": "labs/lab2/lab2.html#introduction",
    "title": "Lab 2: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "In this lab we learned how to use time multiplxing to efficiently use the I/O on our FPGA."
  },
  {
    "objectID": "labs/lab2/lab2.html#lab-overview",
    "href": "labs/lab2/lab2.html#lab-overview",
    "title": "Lab 2: FPGA and MCU Setup and Testing",
    "section": "Lab Overview",
    "text": "Lab Overview\nThe goal for this lab was to power two seven segment displays using seven output pins, by using time multiplexing. In addition to using time multiplexing to run two seven segment displays, transistors were used to drive large currents to the common annodes of the seven segment displays. This allowed pins on the FPGA which aren’t capable of driving large currents themselves to use the transistors as a switch allowing the FPGA to toggle the displays on and off quickly."
  },
  {
    "objectID": "labs/lab2/lab2.html#design-approach",
    "href": "labs/lab2/lab2.html#design-approach",
    "title": "Lab 2: FPGA and MCU Setup and Testing",
    "section": "Design Approach",
    "text": "Design Approach\nTime multiplexing is a way to share expensive hardware for different purposes using specific timing. We used multiplexing in this lab by driving two seperate seven segment displays using only seven pins. How it works in this lab is that the same signal (i.e., the same hexadecimal number) is sent to both seven segments. However, two FPGA pins are used to control the common annode’s on either display, toggling one off while the other is on, and synchonously switching the hexadecimal output with the pwoer toggle at around 240 Hz to make it look as if there are two distinct numbers. Both displays are controlled by their own quad dip switch input, and lastly the sum of both numbers are displayed as a five bit number on five seperate LEDS.\n\n\n\nTwo working seven segment displays using time multiplexing\n\n\nThe systemVerilog code that was flashed onto the fpga followed the block diagram below. The top module Lab 2 has inputs s1 [3:0] and s2 [3:0] which come from each of the quad dip switches. Those inputs then enter ledSum which is just an adder summing the two inputs into sum [4:0]. s1 and s2 also enter the sevenSegment module in addition to the clk signal which comes from the HSOSC. The sevenSegment module then alternates between turning on the left or right led segment using led1 and led2 outputs which are connected to the transistors as well as outputts the correct seg [6:0] output to light up specific segments on the display. led1 and led2 are toggled based on the 4.8 MHz clk signal which is modified to effectively act as a 240 Hz clock which flips led1 and led2 every cycle."
  },
  {
    "objectID": "labs/lab2/lab2.html#testing-approach",
    "href": "labs/lab2/lab2.html#testing-approach",
    "title": "Lab 2: FPGA and MCU Setup and Testing",
    "section": "Testing Approach",
    "text": "Testing Approach\nTo test the modules discussed above a testbench was used to run a device under test. This test bench was quite simple compared to the last lab and did not use test vectors but instead was used to monitor when led1 and led2 toggled on or off and if the correct seg[6:0] was outputted depedning on which segment was powered. The DUT ended up being the segmentSwitcher module. Initially I planned to test each module seperately however the sevenSegment module was tested last week and ledSum just summed two inputs, so I decided to test all of segmentSwitcher. The systemVerilog used is provided below.\nmodule segmentSwitcher_tb();\n // Set up test signals\n logic clk;\n logic [3:0] s1,s2;\n logic led1, led2;\n logic [4:0] sum;\n logic [6:0] seg;\n\n // Instantiate the device under test\n segmentSwitcher dut(.s1(s1),.s2(s2), .clk(clk), .led1(led1),.led2(led2), .seg(seg), .sum(sum));\n\n // Generate clock signal with a period of 10 timesteps.\n always\n   begin\n     clk = 1; #5;\n     clk = 0; #5;\n   end\n\ninitial\n begin\n    // test different inputs\n    s1 = 4'b0000;\n    s2 = 4'b1111;\n    #20;\n    s1 = 4'b1000;\n    s2 = 4'b0001;\n    #20;\n    s1 = 4'b1010;\n    s2 = 4'b1001;\n    #20;\n end\nendmodule\nThe results from the wave function can be seen below. We can see that led1 and led2 oscillate oppositely as intended. In addition seg correctly outputs s1 if led1 is high and s2 if led2 is high. Lastly the summing module successfully sums s1 and s2 together and outputs it to sum."
  },
  {
    "objectID": "labs/lab2/lab2.html#wiring-up-the-board",
    "href": "labs/lab2/lab2.html#wiring-up-the-board",
    "title": "Lab 2: FPGA and MCU Setup and Testing",
    "section": "Wiring up the Board",
    "text": "Wiring up the Board\nAfter writing the system verilog modules and thoroughly testing them in a testbench it was time to wire of the FPGA. The FPGA was wired according to the pin layout below. The transistors used were PNP transistors (PN 2907). These were used to drive the common annodes of the displays to 3.3V and were switched on when P47 and P2 were driven low.  Again resistors were used to limit the current for the I/O pins and the LEDs. The work for calculating the transistor base resistor, the seven segment resistor, and the yellow led resistor are shown below. The data sheet states that the recommended current for the FPGA I/O should be 8 mA. The transistor uses a diode that has a forward foltage of 0.7 V, from there we can calculate the resistance we need to set the current to 8 mA. The resistance ended up being 325 Ohms, which was close enough to the 330 Ohm resistors found in the lab. The seven segment display has a forward voltage of 1.8 V and the target amperage was 8 mA again, resuling in a resistance of 163 Ohms which was close to the 200 Ohm resistor in the cabinet. lastly for the yellow LEDs, I wanted them to be bright so I targeted a higher current of 15 mA, which correlates to a 100 Ohm resistance. Lastly for the addition quad dip switch used in this lab, internal FPGA pull up resistors of 100 kOhm were used."
  },
  {
    "objectID": "labs/lab2/lab2.html#outcome",
    "href": "labs/lab2/lab2.html#outcome",
    "title": "Lab 2: FPGA and MCU Setup and Testing",
    "section": "Outcome",
    "text": "Outcome\nBelow you can see a video of the working double seven segment display as well as the five LEDs showing the sum of the two hexadecimal number. This lab turned out successfully as all requirements were met including multiplexing two seven segment displays off of a single seven segment module using transistors, displaying the correct output depending on the input, and finally not having any visual flickering or bleeding.\nVideo\nHours in lab this week: 16 hours"
  },
  {
    "objectID": "labs/lab4/lab4.html",
    "href": "labs/lab4/lab4.html",
    "title": "Lab 4: Digital Audio",
    "section": "",
    "text": "In this lab we were tasked with using our STM32 MCU to play music."
  },
  {
    "objectID": "labs/lab4/lab4.html#introduction",
    "href": "labs/lab4/lab4.html#introduction",
    "title": "Lab 4: Digital Audio",
    "section": "",
    "text": "In this lab we were tasked with using our STM32 MCU to play music."
  },
  {
    "objectID": "labs/lab4/lab4.html#lab-overview",
    "href": "labs/lab4/lab4.html#lab-overview",
    "title": "Lab 4: Digital Audio",
    "section": "Lab Overview",
    "text": "Lab Overview\nThe goal of the lab was to use the internal peripheral timers of the MCU to generate square waves and toggle a GPIO pin at a specicific frequency. The GPIO pin was then hooked up to an audio circuit that magnified the signal and drove a small speaker. Additionally, the MCU was programmed to read a list of notes (Hz) and duration (ms) to play a score."
  },
  {
    "objectID": "labs/lab4/lab4.html#mcu-design",
    "href": "labs/lab4/lab4.html#mcu-design",
    "title": "Lab 4: Digital Audio",
    "section": "MCU Design",
    "text": "MCU Design\n\nHeaders\nThe first piece designed in this lab were the headers for the specific modules used in the lab as we were not allowed to use any preexisting headers. The header files included were for the RCC, GPIO, TIM6 and TIM16 modules.\n// TIM16.h\n// Header for basic timer\n\n#ifndef TIM16_H\n#define TIM16_H\n\n#include &lt;stdint.h&gt;\n\n///////////////////////////////////////////////////////////////////////////////\n// Definitions\n///////////////////////////////////////////////////////////////////////////////\n\n#define __IO volatile\n\n// Base addresses\n#define TIM16_BASE (0x40014400) // base address of TIM16\n\n/**\n  * @brief Reset and Clock Control\n  */\n\ntypedef struct\n{\n  __IO uint32_t TIM_CR1;     //&lt; tim control register 1\n  __IO uint32_t TIM_CR2;     // tim control register 2\n  uint32_t      RESERVED0;    // Reserved,  \n  __IO uint32_t TIM_DIER;   // tim DMA/Interrupt enable register\n  __IO uint32_t TIM_SR;     // time status register\n  __IO uint32_t TIM_EGR;    // tim event generation register\n  __IO uint32_t TIM_CCMR1;    // tim capture/compare mode register\n  uint32_t      RESERVED1;    // Reserved,  \n  __IO uint32_t TIM_CCER;     // capture/compare mode register\n  __IO uint32_t TIM_CNT;     // tim counter\n  __IO uint32_t TIM_PSC;    // tim prescaler\n  __IO uint32_t TIM_ARR;    // time auto reload register\n  __IO uint32_t TIM_RCR;    // repetition counter register\n  __IO uint32_t TIM_CCR1;    // capture/compare register 1\n  uint32_t      RESERVED2;    // Reserved,\n  uint32_t      RESERVED3;    // Reserved,\n  uint32_t      RESERVED4;    // Reserved,\n  __IO uint32_t TIM_BDTR;    // tim  break and dead-time register \n  __IO uint32_t TIM_DCR;    // DMA control register\n  __IO uint32_t TIM_DMAR;    // 6 DMA address for full transfer\n  __IO uint32_t TIM_OR1;    //  option register 1\n  uint32_t      RESERVED5;    // Reserved,\n  uint32_t      RESERVED6;    // Reserved,\n  uint32_t      RESERVED7;    // Reserved,\n  __IO uint32_t TIM_OR2;    //  option register 2\n}\nAn example header above shows how the Timer 16 module is broken up into different registers starting at the base address of TIM16 making it easy to change a bit in a specific register. These headers could then be used in main to shift bits and call other related functions.\n\n\nClock Control\nBelow is the clock tree of the entire MCU. The first step is sending the system clock signal to all peripherals as they are powered off on reset to save power.\n\nFor this lab I used the default MSI 4 MHz clock as the system clock and enabled the GPIO, TIM6, and TIM16. Additionally before entering timer 6 and timer 16 a prescaler was used to divide the system clock to a 1 MHz signal. Enabling the peripherals and scaling down the clock involved setting the correct registers of the RCC module (reset & clock control) which can be seen at the top of main.\n\n\nTimer 6 (delay)\nTimer 6 or TIM6 which is a basic clock, was used to create a accurate delay in milliseconds that would be used to hold notes for a certain amount of time. You can see how it recieves its internal clock from RCC.\n\n\n\nTIM6 Block Diagram\n\n\nA function called setUpTIM6 was used where timer 6’s inputed clock was scaled down by a factor of 10 leaving it around 100 kHz. It was then updated and its counter was enabled to start counting up at a rate of around 100 kHz.\nFor the delay delayTIM6(int ms) was used. In this function the timer’s auto reload bits were set. Auto reload is a feature that resets the timer’s counter back to zero and raises a status register count matches the ARR register. This allows us to contorl the delay as the auto reload register was set depending on the input ms. The program would then wait till the status register flag was raised before continuing on with any other code. Finally it reset the status register back to zero for the next delay.\n\n\nTimer 16 (PWM)\nTimer 16 or TIM16 is a general purpose timer that has more features than timer 6. It was used to create a PWM signal that was then routed to a GPIO pin. Similarly it recieves its internal clock from RCC.\n\nThe setUpPWM(int frequency, int dutyCycle) was used to enable the timer and have it output a signal at the correct frequency and duty cycle. For PWM the auto reload register and capture/compare register must be set. This is because the output is low when ARR (auto reload register) &lt; CCR1 (capture/compare register) and high when ARR &gt; CCR1. ARR was set based on the timers clock input as well as the function inputs frequency and CCR1 was set to a fraction of ARR depeding on what dutyCycle was inputed as.\nFrom there the auto preload reload, capture/compare, PWM mode, main output, and preload register are enabled in addition to setting the capture/compare channel as an output. Lastly everything was updated and then the counter was enabled for timer 16 to begin counting up.\nTo change the frequency or duty cycle changeFreq(int frequency, int dutyCycle) was used. This function then set ARR and CCR1 according to the specified frequency and duty cycle and updated timer 16.\n\n\nGPIO\nIn E85 we had used GPIO as standard output or input, either reading in low and high signals or outputting low and high signals. But now we want to connect it the output of our timer 16. To do this GPIO alternate function was used. Inside the STM 32 every pin has alternate functions which you can find in the data sheet like the example below.\n\nAs we can see, the output from TIM16_CH1 which is the PWM output in our case, can be routed to pin PA6 if its using alternate function 14. This involved setting the GPIO alternate function low register so that pin 6 was set to AF14.\n\n\nPiecing it Together\nOnce the two timers (delay and PWM) were created and the GPIO was initiated to output to its correct alternate function, the rest was simple. The main function of the c code iterated through an array of frequencies and delays. The code would then tell the MCU to change the frequency of the output PWM and delay it for the specific amount of time till it had to change to the next frequency."
  },
  {
    "objectID": "labs/lab4/lab4.html#calculations",
    "href": "labs/lab4/lab4.html#calculations",
    "title": "Lab 4: Digital Audio",
    "section": "Calculations",
    "text": "Calculations\nThe first calculation was to calibrate exactly what the MSI clock was running at. When the MSI (default at 4 MHz) was routed into TIM16 it was prescaled by four meaning it should’ve have been at a rate of 1 MHz. To evaluate the true frequency of the MSI the following calculations were used.\n\nI started with the ARR formula that calculated the specific auto reload register value for a desired pitch of 496 Hz. When this ARR was used the oscilloscope showed that the actual pitch was around 488 Hz. Using this data the real speed of the scaled MSI could be calculated at 985.533 KHz. While it looks quite far from the expected its only around 1.5% off and the MCU clocks can have error in this range. After using the correct clock speed you can see below we get a much closer pitch of 495 Hz (within 1%).\n\nThe maximum and minimum duration and pitch then had to be calculated to make sure it could accurately play musical pieces. The calculations below show what the range of pitch and delays are.\n\nFor the duration timer I scaled down the clock by 10 to get an input clock of 98.453 Hz which leaves us with a range of delays from 0.01 to 665 ms. In hindsight I did not need to scale down the clock this much as we don’t need a delay that small, however it fit within the bounds of the songs we were trying to play. For the frequency the clock wasn’t scaled down any further which left us with a range of 15 Hz to 984 kHz which goes below and above the range of human hearing making it perfect for an audio output."
  },
  {
    "objectID": "labs/lab4/lab4.html#wiring-the-board",
    "href": "labs/lab4/lab4.html#wiring-the-board",
    "title": "Lab 4: Digital Audio",
    "section": "Wiring the Board",
    "text": "Wiring the Board\nThe wiring for this lab was simple. The output PWM needed to be routed to a small speaker so that the signal could be heard. However the MCU does not have enough current output to drive a speaker. Due to this constraint an audio amplifier was used in the circuit below.\n\nThe LM348 was powered by the 5V voltage regulator on our PCB allowing the output to reach a max of 5 V and have sufficient current. The amplifier did not use any negative feedback but instead just multiplied V+ by the amplifier’s gain of 20. This obviously railed out quickly as PA6 outputted 3.3 V. To control the output voltage and to not annoy others’s in the lab a 10 kOhm potentiometer was used to vary the input signal before it got amplified acting as a volume knob. For fun I also powered the audio amplifier with 12 V from a desktop powersupply and was able to greatly increase the volume. Students in the ECF claimed they could hear it accross the hall."
  },
  {
    "objectID": "labs/lab4/lab4.html#outcome",
    "href": "labs/lab4/lab4.html#outcome",
    "title": "Lab 4: Digital Audio",
    "section": "Outcome",
    "text": "Outcome\nFrom the two videos below you can see my MCU circuit succesffuly playing Für Elise as well the melody of Mo Bamba. Additionally volume support is evident through the use of the potentiometer.\n\n\nWhile this lab was straightforward there were a lot of hiccups and slowdowns. A lot of this frustration came from the PWM as my code had to enable a lot of specific bits in the correct order and it turned out I was forgetting one important bit. Additionally it was hard to debug this lab and know which register we might have been missing, as if 15/16 of the registers were correct but that last one was wrong there would be zero output. However I do feel a lot more comfortable using the STM32 reference manual and data sheet now.\nTime in lab: 19 Hours."
  },
  {
    "objectID": "labs/lab6/lab6.html",
    "href": "labs/lab6/lab6.html",
    "title": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "section": "",
    "text": "In this lab we were tasked with creating an Internet of Things (IoT) device that displayed the temperature of the lab when requested and could control an LED connected to our MCU."
  },
  {
    "objectID": "labs/lab6/lab6.html#introduction",
    "href": "labs/lab6/lab6.html#introduction",
    "title": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "section": "",
    "text": "In this lab we were tasked with creating an Internet of Things (IoT) device that displayed the temperature of the lab when requested and could control an LED connected to our MCU."
  },
  {
    "objectID": "labs/lab6/lab6.html#lab-overview",
    "href": "labs/lab6/lab6.html#lab-overview",
    "title": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "section": "Lab Overview",
    "text": "Lab Overview\nThe goal of this lab was to learn how to tie together multiple different components in conjunction with our MCU to create the desired IoT device. We used an ESP8266 which is a Wi-Fi microcontroller with pre-written web server code to host webpage. The MCU would then communicate with the webpage over UART allowing the MCU to read and write data to the ESP8266 and change the webpage. The MCU would also communicate with a DS1722 Digital Thermometer over SPI, synchonously recieving temperature data and sending it over UART to the page."
  },
  {
    "objectID": "labs/lab6/lab6.html#the-temperature-sensor",
    "href": "labs/lab6/lab6.html#the-temperature-sensor",
    "title": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "section": "The Temperature Sensor",
    "text": "The Temperature Sensor\nThis lab used a DS1722 Digital Thermometer described in the image below.\n\n\n\nPinout of Temperature Sensor\n\n\nThis sensor is able to communicate over both SPI and 3-wire, but in this lab we just used SPI. The MCU Pins were connected to the sensorsSCLK, CE, SDO, and SDI pins. When using SPI the sensor has the following registers.\n\nThe SPI system configured in this lab sent and recieved 8 bits of data. When reading the temperature from the sensor the MCU first writes the 8 bit read address (either 0x01 or 0x02) and then writes 0x0, it then reads what the sensor outputs. Since the sensor only outputs 8 bits but the temperature is sent over 16 bits you must call 0x01 and 0x02 which relate to the LSB and MSB data that need to be concatenated and then converted into a decimal temperature. On this temperature sensor you can also change the configuration depending on the level of resolution you want. When writing to the configuration register the MCU writes 0x80 first to tell the sensor the specific location and then writes the 8 bit configuration according to how many bits of precision you want for the next read."
  },
  {
    "objectID": "labs/lab6/lab6.html#mcu-design",
    "href": "labs/lab6/lab6.html#mcu-design",
    "title": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "section": "MCU Design",
    "text": "MCU Design\nIn this lab our MCU had two jobs. The first was to send data to the webpage over UART to tell it what to display and allow the webpage to send requests to the MCU. In the MCU source code the main function begins by sending the Wi-Fi chip some HTML code for a webpage inlcuding the temperature reading and configuration buttons as well as buttons to control the LED. When it does respond the MCU looks to see if it was a Temperature configuration request or LED request and then calls the respective code to either light up the LED or send an SPI signal to change the configuration register resolution and update the current temperature on the webpage."
  },
  {
    "objectID": "labs/lab6/lab6.html#mcu-pinout",
    "href": "labs/lab6/lab6.html#mcu-pinout",
    "title": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "section": "MCU Pinout",
    "text": "MCU Pinout\nBelow is the pin configuration I used for this lab. The pin’s were relatively simple and just required making sure that specific pins with SPI alternate functions were available to conenct to the temperature sensor."
  },
  {
    "objectID": "labs/lab6/lab6.html#spi-setup",
    "href": "labs/lab6/lab6.html#spi-setup",
    "title": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "section": "SPI SETUP",
    "text": "SPI SETUP\nTo setup up SPI on the MCU the we first had to configure the GPIO pins for MOSI, MISO, and SCK pins. We then configured CPI_CR1 including setting the baud rate, clock phase, clock polarity, full duplex, and setting the MCU to ast as the master. From there the amount of bits transfered on SPI was set to 8 bits and the frame format was set to SPI motorola mode.\nAfter we succesfully initiatied SPI we had to make a function to read and write to the temperature sensor using SPI. In this function the program waited for the transmit buffer to be empty TXE and then sent accross the 8 bit message we wanted to transfer. One unique feature was that the data register that holds the SPI data is 16 bits instead of 8. This meant if we tried to write an 8 bit message to this register the rest of the bits would be zero. To ammend this a pointer to the register was created of type uint8_t and the 8 bit data was then copied to the location the pointer pointed to. The program would then wait until the recieve buffer was full RXNE and return the data in the recieve buffer as a char."
  },
  {
    "objectID": "labs/lab6/lab6.html#calculations",
    "href": "labs/lab6/lab6.html#calculations",
    "title": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "section": "Calculations",
    "text": "Calculations\nThe only calculation in this lab was calulating the decimal temperature from the 8 to 12 bit data we recieved from the sensor using the following conversion.\n\nThis sensor uses twos complement to signify negative numbers. To compute the first 8 temperature bits I simply would check if the first bit was high or low and then add the decimal representation of the next 7 bits to either 0 or -128. For the second set of 8 bits I would mask each bit and check if it was high or low and then add the appropriate fraction to the final temperature reading."
  },
  {
    "objectID": "labs/lab6/lab6.html#testing",
    "href": "labs/lab6/lab6.html#testing",
    "title": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "section": "Testing",
    "text": "Testing\nTo test that the SPI was working, I used a external digital analyzer to monitor the MISO, MOSI, CE, and SCLK pins. the following are two examples of SPI in action. You can clearly see the standard SPI process, first chip enable is set high and then the register locations we want data from are sent over MOSI. Then 8 clock cycles later we get temperature data from MISO. After getting the temperature we needed chip enable is set low again.\n\n\n\n8 bit resolution\n\n\n\n\n\n12 bit resolution\n\n\nThe first image shows the MCU reading both the 0x01 and 0x02 register. Since this is an 8 bit reading we get nothing from 0x01 and we get a value of 17 from 0x02 which correlates to a temperature of 23 celcius. The second image similarly reads the full temperature but since the sensor is configured for 12 bit resolution we see a reading of 0xB0 from register 0x01 and 0x16 from register 0x02 giving us a more accurate temperature of 22.6875 celcius. The logic analyzer turned out to be very useful as it allowed us to insight to what our hardware was doing in realtime.\nOnce the MCU temperature code finally was able to interface with the UART webpage it was time to validate. Launching the website in the digital design lab I found that the webpage would show a reading around 24 C which translates to 75 F. This is right around room temperature where I expected it to be and shows that the temperature converting function works well. One thing that was interesting is when trying to change resolution it often took two clicks to get the resolution to change. We believe this is because it was still changing the configuration and couldn’t fully convert the new temperature before our webpage requested it. I tried to fix this by adding a 1.2s delay, which corresponds to the conversion time of the highest resolution reading, but unfortunately our webpage would time out as it wasn’t getting data frequently enough."
  },
  {
    "objectID": "labs/lab6/lab6.html#outcome",
    "href": "labs/lab6/lab6.html#outcome",
    "title": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "section": "Outcome",
    "text": "Outcome\nFrom the two images below you can see how the website has buttons to select the resolution of the temperature sensor. It also shows the webpage properly displaying temperature at the bottom of the page while keeping all the LED controls available and functional. On top of becoming more confortable using and initializing SPI, this lab provided a nice insight to how webpages work and how we can communicate with them using USART.\n \nTime in Lab this week: 22 Hours"
  },
  {
    "objectID": "posts/eighth-post.html",
    "href": "posts/eighth-post.html",
    "title": "SPI Invention",
    "section": "",
    "text": "You probably know Motorola as the comnpany that sometimes makes wacky phones like the flip phone below.  However they deserve a lot more credit than that. They have created pioneering work in semiconductors, communication equipment, automative electronics, space/satellite technology, computer systems, television and even defense contracts.\nHowever most related to this class is Motorola’s invention of SPI (serial peripheral interface). This week in class we relied on SPI protocol to read temperature data from a temperature sensor. They wanted to develop a protocol that would enable a fast, efficient interface that most importantly used fewer number of wires. While there were other protocols available like I^2C that just uses just a clock and a data line Motorola needed a much faster way to send data. This is where their full duplex SPI came in. Motorola designed it to use four pins MOSI, MISO, SCLK and SS. Motorolla launched their first iteration of SPI with their 68xx microcontrollers and from there it was history. SPI became one of the most well know interfaces in embedded systems as a reliable and fast way to interface with peripherals. You can now find almost any sensor available for SPI Interface from extra addressable memory to gyroscopes.\n\n\n\nSPI Interface"
  },
  {
    "objectID": "posts/first-post.html",
    "href": "posts/first-post.html",
    "title": "Jumping into Micro Ps",
    "section": "",
    "text": "This week in class we focused mostly on reviewing from E85, which I definitely needed. It was clear to me that I had forgotten quite a bit and was nervous that it wouldn’t come back. Luckily I have started to remember the concepts we talked about in E85 over a year ago but some topics still trip me up such as using non blocking &lt;= vs blocking = assign statements. I think repition and completing the labs will definitetly help with this, and I hope to see how much I can grow on my E85 knowledge throughout this semester.\nOne other thing I have been thinking about during this lab is the differenc between using the FPGA and MCU. In E85 we used the FPGA the first half of the labs and the RISC-V based MCU the second half. I’m wondering what are the strength of the FPGA vs MCU and how to know when to use one instead of the other?"
  },
  {
    "objectID": "posts/second-post.html",
    "href": "posts/second-post.html",
    "title": "What is Time Division Multiplexing",
    "section": "",
    "text": "This week we used time multiplexing to drive a seven segment display. However before I attempted or to be honest fully understood the lab I researched time division multiplexing. Looking at the diagram below, you can see how time division multiplexing generally works. The source transmits multiple packets or frames of input data using a mux and then based on an input signal to the demux it sorts them in the right outputs. This makes an efficient way to transmit and recieve independant signal over a commong single path. During my research it reminded me of morse code, where we have the operator on one side who has a message and then turns it into a series of long and short pulses (0’s and 1’s) and then send it to the opeartor on the other side through a single wire. The operator on the other side then acts as the demux configuring it back into a message.\n\n\n\nsrc: scaler.com\n\n\nIn this lab, we used this idea generally, allowing us to send a double wide signal through a single path and then decoding it based on the timing on the other side. One real life example that I had never thought about was telephone calls. They use the same process of time multiplexing to send multiple calls using one wire. I am sure I will begin to see this everwhere now!"
  },
  {
    "objectID": "posts/sixth-post.html",
    "href": "posts/sixth-post.html",
    "title": "Ideating a final project",
    "section": "",
    "text": "This week we started discussing the final project in our Micro Processing deign course. In this course after you complete the first seven labs you have to design and build a half semester long project that uses both the FPGA and MCU. Here are a few of the projects we were thinking about:\nThe first project we thought of was a 2D ball balancing robot similar to the one below.\n\nIt would use stepper motors and PID control to adjust the table. A resistive touch screen would be able to tell the system where the ball was so the table could react to it accordingly. We were really excited about this project but quickly realized that it would involve a big mechanical focus. We decided we wanted to focus on the embedded systems approach and scrapped this idea.\nThe next project we considered was making a rubiks cube solver. Similar to those videos online where a machine takes a scrambled rubiks cube and solves it in just a few seconds.\n\nThis idea would involve analyzing the current state of the cube and using stepper motors to rotate the cube. The one issue with this idea is that we would need a way to see what the colors on the side of the rubiks cube are so that our program could know what moves to maker and rotate the cube until it was solved. This application of computer vision seemed out fo the scope of this class and not feasible.\nWe then pivoted to our third idea…CHESS!!! It was perfect. We could have a smart chess board that kept track of where every chess piece was using hall effect sensors. From there whenever a piece is picked up the leds under the board would will notify the user where they are allow to move their piece. Additional ideas include telling users optimal moves and having sound effects when taking opponents. We are thinking we could have the MCU keep track of every piece on the 8x8 board and the FPGA will communicate with it to light up the chess squares. I hope to started on this as soon as possible."
  }
]