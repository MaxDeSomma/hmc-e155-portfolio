{"title":"Lab 1: FPGA and MCU Setup and Testing","markdown":{"yaml":{"title":"Lab 1: FPGA and MCU Setup and Testing","format":{"html":{"code-links":[{"text":"Lab Repository","href":"https://github.com/MaxDeSomma/e155-lab1","icon":"github"}]}}},"headingText":"Introduction","containsRefs":false,"markdown":"\n\nIn this lab we soldered our E155 protoboard, tested our FPGA and MCU, and  created our own FPGA design to drive onboard LEDs as well as a seven segment display.\n\n## Development Board\nFor the development board we were given we soldered a variety of surface mount technology (SMT) and through hole technology (THT) components. The brains behind the development board consisto of the UPduino v3.1 FPGA and Nucleo-L432KC MCU which were attached through header pins. Additionally switches, voltage regulators, and jumpers to set power for the MCU and FPGA were added to the board. The most difficult part was soldering all the SMT leds, capacitors, and resistors as it was tricky to get them in the correct place with how small they were.\n\n![Completed Development Board](images/protoboard.png)\n\n## Testing the FPGA and MCU\nThe FPGA and MCU were then tested to make sure they worked properly along with all the soldered components on the PCB. They were able to be test by using the onboard PCB LEDs which connect internally to specific pins of the FPGA and MCU. For my board I found that three of my LEDS and one of the current limiting resistors needed to be reflowed. However after reflowing, and using Radiant to program the FPGA and Segger to program the MCU it worked worked succesfully.\n\n![On board LEDs used to test the FPGA and MCU](images/onBoardLeds.png)\n\n## FPGA Design\n### Lab Description\nAfter I had thoroughly tested that my FPGA, MCU, and development board, I designed FPGA modules to control different LEDs. The task was to light up the LED's and a seven segment display depending on what dip switches were selected, described more in the table below. \n\n| Signal  Name | Signal Type | Description |\n|--------------|-------------|-------------|\n| `s[3:0]`  | input| the four DIP switches (on the board, SW6) |\n| `led[2:0]`| output| 3 LEDs (you may use the on-board LEDs) |\n| `seg[6:0]`| output| the segments of a common-anode 7-segment display |\n\nTwo of the LEDs, `led[0]` and `led[1]`, were designed accordingly:\n\n::: {.center-table}\n| `s1` | `s0` | `led[0]` |\n|:----:|:----:|:--------:|\n| 0  | 0  | 0    |\n| 0  | 1  | 1     |\n| 1  | 0  | 1     |\n| 1  | 1  | 0    |\n:::\n\n::: {.center-table}\n| `s3` | `s2` | `led[1]` |\n|:----:|:----:|:--------:|\n| 0    | 0    | 0      |\n| 0    | 1    | 0      |\n| 1    | 0    | 0      |\n| 1    | 1    | 1       |\n:::-\n\n`led[2]` did not follow a truth table but instead was designed to blink at 2.4 Hz. \n\nAs for the seven segment display it needs to read in the dip switch signals and display the four bit binary number as a single hexadecimal number on the seven segment display. For example if the dip switch input `s[3:0]` was `0110` the seven segment display must show a `6` while if it was `1101` it would display a `d`.\n\n### Design\nBelow is the block diagram used to design the combinational logic that that drove both the LEDs and seven segment display:\n\n![](images/lab1BlockDiagram.png)\n\n#### LED Design\n\nTo design `led[0]` and `led[1]` we can clearly see that `led[0]` is simply an exclusive or (XOR gate) of input `s0` and `s1`. While `led[1]` is an and gate of `s2` and `s3`. For `led[2]` it was necessary to make sure it blinked at 2.4 Hz. This means that every cycle of `led[2]` will last around 0.4167 seconds. Using a duty cycle of 50%, the LED needs to switch on or off every 0.2083 seconds. The HSOSC library was utilized to create a clock that oscillated at 48 Mhz meaning it ticks every 2.083*10^-8 seconds. This meant that it would take 10^8 ticks to complete a half cycle for `led[3]`. To design this a flip flop was used that counts every tick and switched the led on or off every 10,000,000 counts.\n\n#### Seven Segment Design\nTo design the seven segment display the SystemVerilog module used a submodule which had an input of `s[3:0]` and an output of `seg[6:0]`. This submodule comntained a case statement with 16 cases, one for each off the possible dip switch combinations (4'b000, 4'b0001, ... , 4'b1111). Once the SystemVerilog checked the case it would then turn off the specific pins that correlated to the specific segments to create each hexadecimal number. One interesting point about the seven segment display is that it was common annode, meaning it had one common pin at 3.3V, meaning the FPGA must drive the desired pin to low to light up the particular segment.\n\n### Testing\nA test bench was used to test the SystemVerilog code was working according to the proposed design. The testbench ran all 16 cominations of the dip switches and tested the expected led[3:0] and expected seg[6:0] outputs vs what the actual output of the modules would be in simulation. \n\n```markdown\n// sevenSeg_testvectors.tv\n// Max De Somma\n// mdesomma@g.hmc.edu\n// 9/3/24\n\n// [3:0]s, [2:0]led, [6:0]segment\n0000_000_1000000\n0001_001_1110011\n0010_001_0100100\n0011_000_0100001\n0100_000_0010011\n0101_001_0001001\n0110_001_0001000\n0111_000_1100011\n1000_000_0000000\n1001_001_0000001\n1010_001_0000010\n1011_000_0011000\n1100_010_1001100\n1101_011_0110000\n1110_011_0001100\n1111_010_0001110\n```\n\nThe test vector file above was the one used in the test bench that had the correct output for every case. Every test passed proving the SystemVerilog code worked correctly. \n\n![](images/testBench.png)\n\nHowever the test bench fell short as `led[2]` was not able to be tested which is clear in the photo above. This was due to the fact that the HSOSC libary was not include in model sim. However it was possible to validate it using an oscilloscope proving it oscillated between 0 V and 3.3V at a freq of 2.42 Hz which is clsoe to the desired 2.40 Hz. \n![](images/2.4HzLED.png)\n\n### Wiring and Outcome\nAfter writing and testing the SystemVerilog, it was time to connect the LED's and Seven Segment to my FPGA using the following wiring schematic.\n\n![](images/pinLayout.png)\n\nHowever to prevent the seven segment drawing too much current, current limiting resistors were added to all seven `seg[7:0]` pins targeting 15 mA. On the seven segment data sheet, it stated that the red led segments had a forward voltage of 1.8 V. This meant that voltage across the resistor would be 1.5 V, and thus could use V = IR with a target current of 0.15 mA to calculate R.\n\n![](images/currentLimitingResistor.png)\n\n After finally wiring all the inputs and the output to the FPGA and downloading the SystemVerilog module to the board the development board was succesfully able to drive the seven segment display and display the correct hexadecimal number and proper onboard LEDs. Additionally as shown above the `led[2]` blinked at the correct 2.4 Hz. This wraped up Lab 1, verifying that the development board worked properly while giving me a chance to design my own FPGA modules. In total this lab took 21 hours. \n\n ![The correct output of led[0] and the Seven Segment displaying 6 for input 4'b0110](images/display6.jpg)\n \n ![The correct output of led[1] and the Seven Segment displaying C for input 4'b110](images/displayC.jpg)","srcMarkdownNoYaml":"\n\n## Introduction\nIn this lab we soldered our E155 protoboard, tested our FPGA and MCU, and  created our own FPGA design to drive onboard LEDs as well as a seven segment display.\n\n## Development Board\nFor the development board we were given we soldered a variety of surface mount technology (SMT) and through hole technology (THT) components. The brains behind the development board consisto of the UPduino v3.1 FPGA and Nucleo-L432KC MCU which were attached through header pins. Additionally switches, voltage regulators, and jumpers to set power for the MCU and FPGA were added to the board. The most difficult part was soldering all the SMT leds, capacitors, and resistors as it was tricky to get them in the correct place with how small they were.\n\n![Completed Development Board](images/protoboard.png)\n\n## Testing the FPGA and MCU\nThe FPGA and MCU were then tested to make sure they worked properly along with all the soldered components on the PCB. They were able to be test by using the onboard PCB LEDs which connect internally to specific pins of the FPGA and MCU. For my board I found that three of my LEDS and one of the current limiting resistors needed to be reflowed. However after reflowing, and using Radiant to program the FPGA and Segger to program the MCU it worked worked succesfully.\n\n![On board LEDs used to test the FPGA and MCU](images/onBoardLeds.png)\n\n## FPGA Design\n### Lab Description\nAfter I had thoroughly tested that my FPGA, MCU, and development board, I designed FPGA modules to control different LEDs. The task was to light up the LED's and a seven segment display depending on what dip switches were selected, described more in the table below. \n\n| Signal  Name | Signal Type | Description |\n|--------------|-------------|-------------|\n| `s[3:0]`  | input| the four DIP switches (on the board, SW6) |\n| `led[2:0]`| output| 3 LEDs (you may use the on-board LEDs) |\n| `seg[6:0]`| output| the segments of a common-anode 7-segment display |\n\nTwo of the LEDs, `led[0]` and `led[1]`, were designed accordingly:\n\n::: {.center-table}\n| `s1` | `s0` | `led[0]` |\n|:----:|:----:|:--------:|\n| 0  | 0  | 0    |\n| 0  | 1  | 1     |\n| 1  | 0  | 1     |\n| 1  | 1  | 0    |\n:::\n\n::: {.center-table}\n| `s3` | `s2` | `led[1]` |\n|:----:|:----:|:--------:|\n| 0    | 0    | 0      |\n| 0    | 1    | 0      |\n| 1    | 0    | 0      |\n| 1    | 1    | 1       |\n:::-\n\n`led[2]` did not follow a truth table but instead was designed to blink at 2.4 Hz. \n\nAs for the seven segment display it needs to read in the dip switch signals and display the four bit binary number as a single hexadecimal number on the seven segment display. For example if the dip switch input `s[3:0]` was `0110` the seven segment display must show a `6` while if it was `1101` it would display a `d`.\n\n### Design\nBelow is the block diagram used to design the combinational logic that that drove both the LEDs and seven segment display:\n\n![](images/lab1BlockDiagram.png)\n\n#### LED Design\n\nTo design `led[0]` and `led[1]` we can clearly see that `led[0]` is simply an exclusive or (XOR gate) of input `s0` and `s1`. While `led[1]` is an and gate of `s2` and `s3`. For `led[2]` it was necessary to make sure it blinked at 2.4 Hz. This means that every cycle of `led[2]` will last around 0.4167 seconds. Using a duty cycle of 50%, the LED needs to switch on or off every 0.2083 seconds. The HSOSC library was utilized to create a clock that oscillated at 48 Mhz meaning it ticks every 2.083*10^-8 seconds. This meant that it would take 10^8 ticks to complete a half cycle for `led[3]`. To design this a flip flop was used that counts every tick and switched the led on or off every 10,000,000 counts.\n\n#### Seven Segment Design\nTo design the seven segment display the SystemVerilog module used a submodule which had an input of `s[3:0]` and an output of `seg[6:0]`. This submodule comntained a case statement with 16 cases, one for each off the possible dip switch combinations (4'b000, 4'b0001, ... , 4'b1111). Once the SystemVerilog checked the case it would then turn off the specific pins that correlated to the specific segments to create each hexadecimal number. One interesting point about the seven segment display is that it was common annode, meaning it had one common pin at 3.3V, meaning the FPGA must drive the desired pin to low to light up the particular segment.\n\n### Testing\nA test bench was used to test the SystemVerilog code was working according to the proposed design. The testbench ran all 16 cominations of the dip switches and tested the expected led[3:0] and expected seg[6:0] outputs vs what the actual output of the modules would be in simulation. \n\n```markdown\n// sevenSeg_testvectors.tv\n// Max De Somma\n// mdesomma@g.hmc.edu\n// 9/3/24\n\n// [3:0]s, [2:0]led, [6:0]segment\n0000_000_1000000\n0001_001_1110011\n0010_001_0100100\n0011_000_0100001\n0100_000_0010011\n0101_001_0001001\n0110_001_0001000\n0111_000_1100011\n1000_000_0000000\n1001_001_0000001\n1010_001_0000010\n1011_000_0011000\n1100_010_1001100\n1101_011_0110000\n1110_011_0001100\n1111_010_0001110\n```\n\nThe test vector file above was the one used in the test bench that had the correct output for every case. Every test passed proving the SystemVerilog code worked correctly. \n\n![](images/testBench.png)\n\nHowever the test bench fell short as `led[2]` was not able to be tested which is clear in the photo above. This was due to the fact that the HSOSC libary was not include in model sim. However it was possible to validate it using an oscilloscope proving it oscillated between 0 V and 3.3V at a freq of 2.42 Hz which is clsoe to the desired 2.40 Hz. \n![](images/2.4HzLED.png)\n\n### Wiring and Outcome\nAfter writing and testing the SystemVerilog, it was time to connect the LED's and Seven Segment to my FPGA using the following wiring schematic.\n\n![](images/pinLayout.png)\n\nHowever to prevent the seven segment drawing too much current, current limiting resistors were added to all seven `seg[7:0]` pins targeting 15 mA. On the seven segment data sheet, it stated that the red led segments had a forward voltage of 1.8 V. This meant that voltage across the resistor would be 1.5 V, and thus could use V = IR with a target current of 0.15 mA to calculate R.\n\n![](images/currentLimitingResistor.png)\n\n After finally wiring all the inputs and the output to the FPGA and downloading the SystemVerilog module to the board the development board was succesfully able to drive the seven segment display and display the correct hexadecimal number and proper onboard LEDs. Additionally as shown above the `led[2]` blinked at the correct 2.4 Hz. This wraped up Lab 1, verifying that the development board worked properly while giving me a chance to design my own FPGA modules. In total this lab took 21 hours. \n\n ![The correct output of led[0] and the Seven Segment displaying 6 for input 4'b0110](images/display6.jpg)\n \n ![The correct output of led[1] and the Seven Segment displaying C for input 4'b110](images/displayC.jpg)"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"toc":true,"output-file":"lab1.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.5.56","theme":"cosmo","title":"Lab 1: FPGA and MCU Setup and Testing","code-links":[{"text":"Lab Repository","href":"https://github.com/MaxDeSomma/e155-lab1","icon":"github"}]},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}